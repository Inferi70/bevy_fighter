For my project, it uses Bevy, and some P2P connection stuff. So, I learned how an ECS works, how some of the WebRTC stuff works, but most importantly, for mine, I learned how rollback games are made and all the desync issues that games have to solve when they try making online games. I failed to make them synced after inputs happen, so I can understand why most opt into using servers to handle game states.

The most difficult thing about this project was all the changes that happen to APIs as they age, like Bevy has a lot of old ways of how things used to be done. So there are tutorials on how to use old ways but have no recent videos showing how the new API works for it. So, you spend a lot of time in Bevy's book, which shows me how important it is to have clear documentation for how to use something. Also, finding that documentation can be extremely hard, like GGRS, which is the rollback system, had good documentation but it's extremely hidden away, so I almost didn't find it whatsoever.

Overall, I find Bevy to be straightforward for creating things, but when you need complicated logic, that's when Bevy gets kind of hard. Like mouse inputs affecting objects, there used to be libraries, but those don't support new Bevy versions, so either you make everything by hand or use a different game engine. So it can be very frustrating to do simple things that should be made into a game engine, but overall, the philosophy that Bevy goes for is fantastic. It's just really in the early stages.

Doing this project has made me understand how to use Rust a lot better because I have to find out how Bevy had things implemented, what data structure they used, so it gave me insight into how Rust can solve various problems. I still need to learn more Rust, so I'll probably end up doing all the Advent of Coding challenges to try filling in gaps I have in Rust.

I think this class overall was a fantastic experience. The only problems I ran into were having the time to do some of the projects. I wouldn't come back to some of the projects because they were relatively simple, and I was after stuff that challenges me more than writing libraries. But I understand why you'd pick these projects because it shows how Rust solves and handles these kinds of problems, which I really like. I'll spend a lot more time writing Rust code after this class because I feel like I know more of how the language is implemented. Like C++, a lot of the standard libraries I have no clue how they work, but we've dug into that in class for some, which I really enjoyed. Overall, I'd teach the class the same but with like two fewer projects and just make the other projects slightly more challenging.

THANKS for teaching Rust; it was fun.
